---
title: "Getting started with timeternR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with timeternR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center"
)
devtools::load_all()
```

<left>
![](timeternRhex.png){width=100px}
</left>

# Installation

To install `timeternR`, run the folllowing code.

```{r eval = FALSE}
if(!require(timeternR)){
  library(devtools)
  devtools::install_github("shannong19/timeternR")
}
library(timeternR)
```

```{r echo = F, message = F, warning = F}
# hidden load currently
library(devtools)
devtools::load_all()
```

# Quickstart

```{r setup, message = FALSE, warning = FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggtern)
```

The following example comes from a Measles outbreak in Hagelloch, Germany in 1861. We have data on each child (agent) in the town.The data we use (as seen below) has each child's information relative to when they were reported to be infected and recovered, information on their school class.

```{r quickstart, fig.width=6, eval=TRUE, message=F}
## Visualizing epidemic progression using timeternR
library(kableExtra)
timeternR::hagelloch_raw %>% head() %>%
  select(PN, NAME, AGE, SEX,
         tPRO, tERU, tI, tR) %>%
  knitr::kable() %>%
  kableExtra::kable_styling()

```

To understand to epidemic we can examine it through an "aggregate" lense (using `geom_aggregate`), which aggregates the groups to find the number of susceptible, infectious, and recovered, and plots them in the ternary view.

```{r}
theme_set(theme_minimal())

hagelloch_raw %>%
  ggplot(aes(y = tI, z = tR)) +
    geom_aggregate() + 
    coord_tern() +
    labs(x = "S", y = "I", z = "R", title = "Town analysis")
```

Previous work has suggested that the class (`CL`) the student was in effected how the experienced the outbreak. The below figure shows differences in the outbreak relative to this grouping.

```{r}
hagelloch_raw %>% 
  rename(`school grade` = CL) %>%
  group_by(`school grade`) %>%
  summarize(`number of students` = n()) %>%
  knitr::kable() %>%
  kableExtra::kable_styling()
```

```{r}
hagelloch_raw %>%
   ggplot(aes(y = tI, z = tR, color = CL)) +
       geom_aggregate() + 
       coord_tern() +
       labs(x = "S", y = "I", z = "R",
            color = "School grade",
            title = "Town analysis by grade") +
       scale_color_brewer(type = "qual")
``` 


## Simulating epidemics with `simulate_SIR_agents`.

The below code simulates SIR data at the individual (or agent) level, aggregates it into SIR format, and plots it in the ``standard'' view of *percent in state* vs. *time*.
	
```{r, eval = TRUE, fig.asp = .62, out.width = '60%'}
n_sims <- 1
n_time_steps <- 100
beta <- .1
gamma <- .03
init_SIR <- c(950, 50, 0)
    
out <- timeternR::simulate_SIR_agents(n_sims = n_sims,
                                 n_time_steps = n_time_steps,
                                 beta = beta, gamma = gamma,
                                 init_SIR = init_SIR)
              
df_ave <- out %>% agents_to_aggregate_SIR() %>%
  group_by(t) %>% summarize(S = mean(S), I = mean(I), R = mean(R))

                   
if (tidyr_new_interface()){ # if tidyr version > 0.8.99
  df_ave_lines <- df_ave %>% pivot_longer(names_to = "State", 
                                          values_to = "Value",
                                          cols = c(S, I, R))
} else {
  df_ave_lines <- df_ave %>% gather(key = "State", value = "Value",
                                S, I, R)
}

ggplot(data = df_ave_lines,
       aes(x = t, y = Value, group = State, col = State)) +
  geom_line()

ggplot(data = df_ave_lines,
       aes(x = t, y = Value)) +
  facet_grid(State ~ .) + 
  geom_line() 


```

We visualize this simulation with a single line in the following way.

```{r}
ggplot(data = df_ave, aes(x = S, y = I, z = R)) + geom_path() +
  coord_tern()
```

## Simulating and visualizing multiple epidemics 

We can also simulation multiple epidemics with different parameters (and can also examine simulations from both `pomp` and `epiModels` packages).

Using the same simulation parameters above we can simulate 50 epidemics:

```{r, eval = TRUE, fig.asp = .62, out.width = '60%'}
n_sims <- 50 # only code changed
n_time_steps <- 100
beta <- .1
gamma <- .03
init_SIR <- c(950, 50, 0)

    
out <- timeternR::simulate_SIR_agents(n_sims = n_sims,
                                 n_time_steps = n_time_steps,
                                 beta = beta, gamma = gamma,
                                 init_SIR = init_SIR)
          
```

We then use the `agents_to_aggregate` function to do the same thing (note that it preforms different for `grouped_df`s and standard `data.frame`s - as it's a method):

```{r}
df_group <- out %>% group_by(sim) %>% agents_to_aggregate_SIR()

ggplot(df_group, aes(x = S, y = I, z = R, group = sim)) +
  geom_path(alpha = .1) +
  coord_tern()
```

What's more if we want to compare the original simulation with these new simulations (and see how well they match) we can do the following:

```{r}
ggplot() + 
  geom_path(data = df_ave, aes(x = S, y = I, z = R)) +
  geom_path(data = df_group, aes(x = S, y = I, z = R, group = sim),
       alpha = .1) +
  coord_tern() 
```

How extreme is the first simulation compared to the rest? Let's create a empirical 95% confidence band from the later simulations.

```{r}
ggplot() + 
  geom_confidence_band(data = df_group, 
                       aes(x = S, y = I, z = R,
                           sim_group = as.numeric(as.character(sim))),
                       fill = "blue", color = NA, alpha = .2,
                       alpha_level = .05, grid_size = rep(100, 2),
                       cb_type = "delta_ball"
                       ) +
  geom_path(data = df_ave, aes(x = S, y = I, z = R)) +
  coord_tern() 
# note: the error message actually comes from the geom_path
```

Here's a demo of all current confidence bands:
```{r fig.width = 7}
vis_data <- timeternR::pomp_df %>%
  rename(x = "S", y = "I", z = "R") %>%
  ggplot(aes(x = x, y =y, z = z, group = .id)) +
  geom_path(alpha = .03) +
  coord_tern() +
  labs(title = "Actually data paths")

vis_spherical <- timeternR::pomp_df %>%
  rename(x = "S", y = "I", z = "R", t = "time") %>%
  ggplot(aes(x = x, y = y, z = z, t = t)) +
  geom_confidence_band(cb_type = "spherical_ball",
                       grid_size = rep(300,2),
                       alpha_level = .95) +
  coord_tern() +
  labs(title = "Spherical CB")

vis_delta_ball <- timeternR::pomp_df %>%
  rename(x = "S", y = "I", z = "R") %>%
  mutate(.id = as.numeric(.id)) %>%
  ggplot(aes(x = x, y = y, z = z, sim_group = .id)) +
  geom_confidence_band(cb_type = "delta_ball",
                       grid_size = rep(300,2),
                       alpha_level = .95) +
  coord_tern() +
  labs(title = "Delta-ball CB")

vis_kde <- timeternR::pomp_df %>%
  rename(x = "S", y = "I", z = "R") %>%
  mutate(.id = as.numeric(.id)) %>%
  ggplot(aes(x = x, y = y, z = z, sim_group = .id)) +
  geom_confidence_band(cb_type = "kde",
                       grid_size = rep(300,2),
                       alpha_level = .95) +
  coord_tern() +
  labs(title = "KDE CB")

vis_convex_hull <- timeternR::pomp_df %>%
  rename(x = "S", y = "I", z = "R") %>%
  mutate(.id = as.numeric(.id)) %>%
  ggplot(aes(x = x, y = y, z = z, sim_group = .id)) +
  geom_path(stat = StatConfBandConvexHull,
            alpha_level = .95) +
  coord_tern() +
 labs(title = "Convex hull CB")

grid.arrange(vis_data, vis_spherical,
             vis_delta_ball, vis_kde,
             vis_convex_hull, nrow = 2)
```
