---
title: "Getting started with timeternR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with timeternR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center"
)
devtools::load_all()
```

<left>
![](timeternRhex.png){width=100px}
</left>

# Installation

To install `timeternR`, run the folllowing code.

```{r eval = FALSE}
if(!require(timeternR)){
  library(devtools)
  devtools::install_github("shannong19/timeternR")
}
library(timeternR)
```

For this package, we currently use 2 github based packages which you can load in the following manner:

```{r eval=FALSE}
library(devtools)
devtools::install_github("Mr8ND/TC-prediction-bands/TCpredictionbands")
devtools::install_github("ngloe/olpsR")
```


```{r echo = F, message = F, warning = F}
# hidden load currently
library(devtools)
devtools::load_all()
```

# Quickstart

```{r setup, message = FALSE, warning = FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
library(ggtern)
```

The below takes a data frame of individuals who have reported infection and recovery times, groups them into male and females, aggregates the groups to find the number of susceptible, infectious, and recovered, and plots them in the ternary view.

```{r quickstart, fig.width=6, eval=TRUE}
## Visualizing epidemic progression using timeternR
library(kableExtra)
timeternR::hagelloch_raw %>% head() %>%
  select(PN, NAME, AGE, SEX,
         tPRO, tERU, tI, tR) %>%
  knitr::kable() %>%
  kableExtra::kable_styling()

```

```{r}
theme_set(theme_minimal())

timeternR::hagelloch_raw %>%
   filter(SEX %in% c("male", "female")) %>%
   ggplot(aes(y = tI, z = tR, color = SEX)) +
   geom_sir(data_type = "raw") + 
   geom_point(stat = "SirRaw") + 
     coord_tern() +
     labs(x = "S", y = "I", z = "R",
          color = "Gender") 
```


## Simulating epidemics with `simulate_SIR_agents`.

The below code simulates SIR data at the individual (or agent) level, aggregates it into SIR format, and plots it in the ``standard'' view of *percent in state* vs. *time*.
	
```{r, eval = TRUE, fig.asp = .62, out.width = '60%'}
n_sims <- 1
n_time_steps <- 100
beta <- .1
gamma <- .03
init_SIR <- c(950, 50, 0)
output_format <- "data.frame"
    
out <- timeternR::simulate_SIR_agents(n_sims = n_sims,
                                 n_time_steps = n_time_steps,
                                 beta = beta, gamma = gamma,
                                 init_SIR = init_SIR,
                                 output_format = output_format)
              
df_ave <- out %>% agents_to_aggregate_SIR %>%
  group_by(t) %>% summarize(S = mean(S), I = mean(I), R = mean(R))

                   
if (tidyr_new_interface()){ # if tidyr version > 0.8.99
  df_ave_lines <- df_ave %>% pivot_longer(names_to = "State", 
                                          values_to = "Value",
                                          cols = c(S, I, R))
} else {
  df_ave_lines <- df_ave %>% gather(key = "State", value = "Value",
                                S, I, R)
}

ggplot(data = df_ave_lines,
       aes(x = t, y = Value, group = State, col = State)) +
  geom_line()

ggplot(data = df_ave_lines,
       aes(x = t, y = Value)) +
  facet_grid(State ~ .) + 
  geom_line() 


```

We visualize this simulation with a single line in the following way.

```{r}
ggplot(data = df_ave, aes(x = S, y = I, z = R)) + geom_path() +
  coord_tern()
```

## Simulating and visualizing multiple epidemics 

We can also simulation multiple epidemics with different parameters (and can also examine simulations from both `pomp` and `epiModels` packages).

Using the same simulation parameters above we can simulate 50 epidemics:

```{r, eval = TRUE, fig.asp = .62, out.width = '60%'}
n_sims <- 50 # only code changed
n_time_steps <- 100
beta <- .1
gamma <- .03
init_SIR <- c(950, 50, 0)
output_format <- "data.frame"
    
out <- timeternR::simulate_SIR_agents(n_sims = n_sims,
                                 n_time_steps = n_time_steps,
                                 beta = beta, gamma = gamma,
                                 init_SIR = init_SIR,
                                 output_format = output_format)
          
```

We then use the `agents_to_aggregate_SIR` function to do the same thing (note that it preforms different for `grouped_df`s and standard `data.frame`s - as it's a method):

```{r}
df_group <- out %>% group_by(sim) %>% agents_to_aggregate_SIR 

ggplot(df_group, aes(x = S, y = I, z = R, group = sim)) +
  geom_path(alpha = .1) +
  coord_tern()
```

What's more if we want to compare the original simulation with these new simulations (and see how well they match) we can do the following:

```{r}
ggplot() + 
  geom_path(data = df_ave, aes(x = S, y = I, z = R)) +
  geom_path(data = df_group, aes(x = S, y = I, z = R, group = sim),
       alpha = .1) +
  coord_tern() 
```

How extreme is the first simulation compared to the rest? Let's create a empirical 95% confidence band from the later simulations.

```{r}
ggplot() + 
  geom_confidence_band(data = df_group, 
                       aes(x = S, y = I, z = R,
                           sim_group = as.numeric(as.character(sim))),
                       fill = "blue", color = NA, alpha = .2,
                       alpha_level = .05, grid_size = rep(100, 2),
                       cb_type = "delta_ball"
                       ) +
  geom_path(data = df_ave, aes(x = S, y = I, z = R)) +
  coord_tern() 
# note: the error message actually comes from the geom_path
```

Here's a demo of all current confidence bands:
```{r fig.width = 7}
vis_data <- timeternR::pomp_df %>%
  rename(x = "S", y = "I", z = "R") %>%
  ggplot(aes(x = x, y =y, z = z, group = .id)) +
  geom_path(alpha = .03) +
  coord_tern() +
  labs(title = "Actually data paths")

vis_spherical <- timeternR::pomp_df %>%
  rename(x = "S", y = "I", z = "R", t = "time") %>%
  ggplot(aes(x = x, y = y, z = z, t = t)) +
  geom_confidence_band(cb_type = "spherical_ball",
                       grid_size = rep(300,2),
                       alpha_level = .95) +
  coord_tern() +
  labs(title = "Spherical CB")

vis_delta_ball <- timeternR::pomp_df %>%
  rename(x = "S", y = "I", z = "R") %>%
  mutate(.id = as.numeric(.id)) %>%
  ggplot(aes(x = x, y = y, z = z, sim_group = .id)) +
  geom_confidence_band(cb_type = "delta_ball",
                       grid_size = rep(300,2),
                       alpha_level = .95) +
  coord_tern() +
  labs(title = "Delta-ball CB")

vis_kde <- timeternR::pomp_df %>%
  rename(x = "S", y = "I", z = "R") %>%
  mutate(.id = as.numeric(.id)) %>%
  ggplot(aes(x = x, y = y, z = z, sim_group = .id)) +
  geom_confidence_band(cb_type = "kde",
                       grid_size = rep(300,2),
                       alpha_level = .95) +
  coord_tern() +
  labs(title = "KDE CB")

vis_convex_hull <- timeternR::pomp_df %>%
  rename(x = "S", y = "I", z = "R") %>%
  mutate(.id = as.numeric(.id)) %>%
  ggplot(aes(x = x, y = y, z = z, sim_group = .id)) +
  geom_path(stat = StatConfBandConvexHull,
            alpha_level = .95) +
  coord_tern() +
 labs(title = "Convex hull CB")

grid.arrange(vis_data, vis_spherical,
             vis_delta_ball, vis_kde,
             vis_convex_hull, nrow = 2)
```
