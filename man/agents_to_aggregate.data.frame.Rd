% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agent-to-aggregate.R
\name{agents_to_aggregate.data.frame}
\alias{agents_to_aggregate.data.frame}
\title{generalized function to convert raw agent based data to aggregate data}
\usage{
\method{agents_to_aggregate}{data.frame}(
  agents,
  states,
  death = NULL,
  birth = NULL,
  min_max_time = c(0, NA),
  integer_time_expansion = TRUE
)
}
\arguments{
\item{agents}{data frame with individual agent information}

\item{states}{Name-variable pairs of the form \code{states = c(col1, col2)},
that describe which columns contain the time one entered the state. Do not
include column for original state. These need to be ordered, for example:
for an SIR model, with columns "\code{tI}" and "\code{tR}" expressing the
time the individual became infected and recovered (respectively), we want
"\code{states = c(tI, tR)}".}

\item{death}{string for column with death time information (default
\code{NULL})}

\item{birth}{string for column with birth time information (default
\code{NULL})}

\item{min_max_time}{vector (length 2) of minimum and maximum integer time,
the second value can be \code{NA} - and if so, we estimate maximum time
from the data.}

\item{integer_time_expansion}{boolean if every integer time point in the 
range of \code{min_max_time} should be presented in the aggregation output.
If \code{FALSE} (default is \code{TRUE}), then lines will only include those
time points where}
}
\value{
dataset with aggregated information, We label classes "\code{X\{i\}}"
  for i in \code{0:(length(states))}.
}
\description{
This function converts data on an agent-based level (1 row = 1 agent)
relative when an agent is in each state and aggregates it, so that the user
can know how many agents are in each state at a given time point (integer
based).
}
\details{
note that all parameters related to name columns can also be in a
  string format. More details can be found in \code{agents_to_aggregate}'s
  documentation.
}
\examples{
library(dplyr)
agents <- EpiCompare::hagelloch_raw
# making babies
set.seed(5)
babies <- sample(nrow(agents),size = 5)
agents$tBIRTH <- NA
agents$tBIRTH[babies] <- agents$tI[babies] - 5

aggregate_b <- agents_to_aggregate(agents, states = c(tI, tR),
                                   death = NULL, birth = tBIRTH)

# looking at when babies where born:
agents \%>\% dplyr::filter(!is.na(.data$tBIRTH)) \%>\%
  dplyr::pull(.data$tBIRTH) \%>\% ceiling() \%>\% sort
# vs:
data.frame(counts = 1:nrow(aggregate_b),
           num_people = aggregate_b \%>\% select(-t) \%>\% apply(1, sum))


# including death
aggregate_d <- agents_to_aggregate(agents, states = c(tI, tR),
                                   death = tDEAD, birth = NULL)

# looking at when people died:
agents \%>\% dplyr::filter(!is.na(.data$tDEAD)) \%>\%
  dplyr::pull(.data$tDEAD) \%>\% ceiling() \%>\% sort
# vs:
data.frame(counts = 1:nrow(aggregate_d),
           num_people = aggregate_d \%>\% select(-t) \%>\% apply(1, sum))
}
